# USAGE

## environment
set the database/cache location. this may move to $HOME/.{cache,local} but is currently user-defined

    export WEB=$HOME/web

directories in [../bin/](../bin/) are categories of utils for **PATH**. to enable DNS/HTTP server launchers and tools for subscription maintenance:

    export PATH=$HOME/src/webize/bin/config:$HOME/src/webize/bin/server:$PATH

now you're ready to launch. the recommended simple solution, in a pair of parallel terminal panes:

    dnsd
    httpd

environment variable **ADDR** the DNS server returns for names in the blocklist to direct traffic to httpd for rewrites. if you have an egress server on your personal LAN as expanded upon elsewhere in the documentation:

    ADDR=10.10.10.1 dnsd

send all traffic to your server with **http_proxy** set at the client, or the server in chained topologies:

    HTTP_PROXY=http://localhost:8000 curl -iH "Accept: text/turtle"

when **OFFLINE** is set, requests are serviced from local cache. for an offline, verbosely-logged HTTP server:

    CONSOLE_LEVEL=debug OFFLINE=1 httpd

set **UNFILTERED** for DNS and it will let traffic through but highlight new domains as usual. this is a way to find new 'cookieless targeting' startups if you're looking for a job or want to add to your blocklist:

    UNFILTERED=1 dnsd

there's also https, due to the triviality of supporting this via Falcon. we stopped using MITM, preferring URI-rewrites, as walking the user through importing a cert authority so we can use SNI to dynamically mint SSL contexts/certs is annoying, though doable everywhere thanks to it being a requirement in corporate compliance/monitoring contexts. extreme-mode global HTTPS termination isn't the only use though - maybe you just don't have wireguard/nebula and prefer app-level encryption:

    https

## auth
[bookmarklet](../config/bookmarks/UI.u) jumps browsing context from upstream to proxy with upstream cookies. this is just enough to quell Twitter/Imperva/Incapsula errors without involving HTTPS MITM or browser plugins. Cloudflare and FB often soon revert to blocking requests. it's a huge cat&mouse game to get all potential fingerprinting sources matching a 'full fat' client with different SSL/TLS library/ciphersuites and HTTPS versions, cloned headers slightly tweaked by Rack's header-to-CGI-var munging, cache invalidations from 'Vary' headers or resource-integrity hashes, short token-expiry, HTTP-only flags on cookie visibility etc that i'm too lazy to try to make that stuff readable as it's mostly a lot of autogenerated blogspam and there's ctrl-W for when these cloud-middleware overlords are too much an adversary to basic low-traffic read-only access to the web.

## peers
each of your devices can (if it has 256M of RAM) host their own daemon - with the default [falcon](https://github.com/socketry/falcon) backend you no longer have to blow away scarce RAM on mobile/SBC devices with an archaic preforking model. peer servers improve cache availability during network segmentation, reduce pipe-utilization when online, and allow for update propagation without third-party dependencies like rsync. define peer servers in the HOSTS file, and listen on HTTP ports on a private net provided via [Nebula](https://www.defined.net/)/[Tailscale](https://tailscale.com/)/[Zerotier](https://www.zerotier.com/), or use HTTPS on the public net. see [this](../bin/config/certificate) for certificate minting