# USAGE
``` sh
cd bin/server
./dnsd   # DNS service
./httpd  # HTTP service
```

## environment
**ADDR** is the address DNS server returns for names in the blocklist - useful to send traffic to a proxy for rewrites/substitutions. send all traffic to a proxy with **http_proxy** set at the client or server (for chained-proxy topologies). go without env vars or system resolver/proxy settings by using a split routing scheme for HTTP and DNS, see [proxy_routes](../bin/proxy_routes). this is the recommended approach for untrusted apps which may ignore system proxy and DNS preferences. this requires uid separation between apps and proxy, which Android has in its app-sandbox uids. traditional distros may already have a proxy user configured if you've installed Squid, Varnish, etc. when **OFFLINE** is set, requests are serviced from local cache. for verbose logs launch the server with: **CONSOLE_LEVEL**=debug httpd.

for simplicity sake and full visibility into DNS and HTTP logs without packet sniffing tools, we like system DNS and HTTP proxy settings pointing to our daemons, themselves accepting the stock system settings provided by the system environment / libc. this poses a mild dilemma when we want to bypass this configuration for features like 'temporarily unblock' or to do some Bing/DDG/Google searching but keep the domains blocked in DNS (because otherwise the browser (on a low-end ARM/MIPS/RISC-V tablet device, in its stock configuration which usually we're subject to due to dotfile-wipe-before-launch) becomes bogged down and slow due to doing all the autocomplete gunk on the URL-bar, to say nothing of the privacy/tracking implications of sending every keystroke to Google or Microsoft). in a severely RAM-constrained environment, you could use Ruby's [resolv-replace](https://github.com/ruby/resolv-replace) right on the primary daemon, but you'd lose DNS visibility and control entirely on the bulk of the traffic, and we've encountered situations where it didn't work or even threw errors during configuration (especially when say, being slightly exotic by using musl's resolver when most developers and early-adopters are using something that involves systemd-resolved or Apple's OSes somehow, so real-world testing is slim. and now we've got gethostbyname under active rewriting by Ruby gods for better Fiber/Ractor concurrency and performance, potentially throwing brief new temporary wrenches into the works). it's not worth adding to the fragility of the main request path over this niche use case of 'temporary allow'. so we've introduced an environment var named **UNFILTERED** to turn those features on. run it on the DNS, and it will let everything through, but still highlight new domains in the log as usual. this is one way to find new 'cookieless targeting' companies if you're looking for a job or want to add to the blocklist. similarly running **UNFILTERED** HTTP will let you access sites in the DNS filter. there are other ways not involving env vars, like using per-uid DNS configuration, which we still use on Android since the per-uid sandboxing is so pervasive and well supported, and meshes nicely with the uid of Termux having a different uid than the app you're using, and it's rigidly enforced by the kernel and iptables so you don't have to worry about apps getting ideas about bypassing system settings when all traffic destined to 1.1.1.1/8.8.8.8/9.9.9.9 or port 53 as a whole is sent to us first for handling. or, your 'unfiltered' egress server could be on a different machine entirely, we have tended to just configure one for all our machines and run it on a small cloud slice with transport encrypted by Nebula so we don't have to faff about with non-port-80 HTTP stuff when it's hardly just port 80 stuff we wanted encrypted in the first place. that's also a nice way to not eat the RAM for two daemons on every device, and have a centrally available log for 'potentially dodgy' traffic.

## auth hoop-jumping
[bookmarklet](../config/bookmarks/UI.u) jumps context from upstream to proxy with upstream cookies. this is just enough to quell Twitter/Imperva/Incapsula errors without involving HTTPS MITM or browser plugins. Cloudflare and FB often soon revert to blocking requests. it's a huge cat&mouse game to get all potential fingerprinting sources matching a 'full fat' client with different SSL/TLS library/ciphersuites and HTTPS versions, cloned headers slightly tweaked by Rack's header-to-CGI-var munging, cache invalidations from 'Vary' headers or resource-integrity hashes, short token-expiry, HTTP-only flags on cookie visibility etc that i'm too lazy to try to make that stuff readable as it's mostly a lot of autogenerated blogspam and there's ctrl-W for when these cloud-middleware overlords are too much an adversary to basic low-traffic read-only access to the web.

## peers
each of your devices can probably host their own daemon - with the default [falcon](https://github.com/socketry/falcon) backend you no longer have to blow away scarce RAM on mobile/SBC devices with an archaic preforking model. peer servers improve cache availability during network segmentation and reduce pipe-utilization when online. define peer servers in the HOSTS file, and listen on HTTP ports on a private net provided via [Nebula](https://www.defined.net/)/[Tailscale](https://tailscale.com/)/[Zerotier](https://www.zerotier.com/), or use HTTPS on the public net. see [this](../bin/certificate) for certificate minting