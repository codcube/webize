# USAGE
``` sh
cd bin/server
./dnsd   # DNS service
./httpd  # HTTP service
```

## auth
[bookmarklet](config/bookmarks/UI.u) jumps from upstream to proxy URL with upstream cookies. this is just just enough to quell Twitter/Imperva/Incapsula errors without involving HTTPS MITM or browser plugins. Cloudflare and FB often soon revert to blocking requests. it's a huge cat&mouse game to get all the potential fingerprinting sources matching a 'full fat' client with different SSL/TLS library/ciphersuites and HTTPS versions, cloned headers slightly tweaked by Rack's header-to-CGI-var case-munging, cache invalidations from 'Vary' headers or resource-integrity hashes, short token-expiry, HTTP-only flags on cookie visibility etc that i'm too lazy to try to make that stuff readable as it's mostly a lot of autogenerated blogspam and there's ctrl-W for when these cloud-middleware overlords are too much an adversary to basic low-traffic read-only access to the web.

## customization
edit site behaviors in [site.rb](config/site.rb). ideally none are necessary as the goal is to eliminate special handling. to eliminate nearly-always-wasteful update checks, declarative [config](config/) updates require a process restart

## environment variables
**ADDR** is an address DNS server returns for names in the blocklist, useful to send traffic to a proxy for rewriting. send all traffic with **http_proxy** set at the client or proxy (for chained scenarios). go without env vars or system resolver/proxy settings by using a split routing scheme for HTTP and DNS, see [proxy_routes](bin/proxy_routes). this is the recommended approach for dodgy apps you can't trust to follow system proxy and DNS settings. it requires uid separation between apps and proxy, which Android has in its app-sandbox uids. traditional distros may already have a proxy user if you've installed squid. when **OFFLINE** is set, requests are serviced from local cache. **VERBOSE** gives the logs more detail, mainly headers for client<>proxy and proxy<>origin requests.

## peers
each device can have its own HTTP(S) server - with the excellent [falcon](https://github.com/socketry/falcon) or [tipi](https://github.com/digital-fabric/tipi), you no longer have to blow away scarce RAM on low-end mobile/SBC devices with an oldschool preforking model. peer servers improve cache availability when offline and reduce pipe-utilization when online. define peers in your HOSTS file, and listen on HTTP ports on a private overlay net from Nebula/Wireguard/Zerotier, or HTTPS if publicly accessible. see [this](bin/certificate) for CA-cert minting for auto-certminting.