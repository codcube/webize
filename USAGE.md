# USAGE
``` sh
cd bin/server
./dnsd   # DNS service
./httpd  # HTTP service
```

## auth
[bookmarklet](config/bookmarklet) jumps from upstream to proxy URL with upstream cookies. this is just just enough to quell Twitter/Imperva/Incapsula errors without involving HTTPS MITM or browser plugins. Cloudflare and FB often soon revert to blocking requests. it's a huge cat&mouse game to get all the potential fingerprinting sources matching a 'full fat' client with different SSL/TLS library/ciphersuites and HTTPS versions, cloned headers slightly tweaked by Rack's header-to-CGI-var case-munging, cache invalidations from 'Vary' headers or resource-integrity hashes, short token-expiry, HTTP-only flags on cookie visibility etc that i'm too lazy to try to make that stuff readable as it's mostly a lot of autogenerated blogspam and there's ctrl-W for when these cloud-middleware overlords are too much an adversary to basic low-traffic read-only access to the web.

## customization
edit site behaviors in [site.rb](config/site.rb). ideally none are necessary as the goal is to eliminate special handling. to eliminate nearly-always wasteful update checks, declarative [config](config/) updates require a process restart

## environment
**ADDR** is an address DNS server returns for names in the blocklist. another way to send traffic to the proxy is to set **HTTP_PROXY** at the client, or proxy for chained scenarios. you can go without env vars or system resolver/proxy settings by using a split-horizon routing scheme for HTTP and DNS, see the commented section in [proxy_routes](bin/proxy_routes). this is the recommended approach for dodgy apps you can't trust to follow system proxy and DNS settings. it requires uid separation between apps and proxy, which Android has in its app-sandbox uids. traditional distros may already have a proxy user if you've installed squid. when **OFFLINE** is set, requests are serviced from local cache. **VERBOSE** gives the logs more detail, mainly headers for client<>proxy and proxy<>origin requests.

## peers
each device typically has one HTTP(S) server running. with the excellent [falcon](https://github.com/socketry/falcon) and [tipi](https://github.com/digital-fabric/tipi), you no longer have to blow away RAM on low-end mobile/SBC devices with an oldschool preforking model. peer servers improve cache availability when offline and reduce pipe-utilization when online. define peers in your HOSTS file, and listen on HTTP ports on a private overlay net from Nebula/Wireguard/Zerotier, or HTTPS if publicly accessible. see [this](bin/certificate) for CA-cert minting for auto-certminting.